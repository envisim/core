import {
  type CategoricalProperty,
  type FeatureCollection,
  type GeoJSON as GJ,
  PropertyRecord,
  type PureObject,
} from '@envisim/geojson-utils';

import {
  type SampleBaseOptions,
  type SampleBeltOnAreaOptions,
  type SampleFeatureOptions,
  type SamplePointOptions,
  type SampleRelascopePointsOptions,
  type SampleSystematicLineOnAreaOptions,
} from './sample-continuous/index.js';
import {type SampleFiniteOptions} from './sample-finite/index.js';
import {SamplingError} from './sampling-error.js';
import {type ErrorType} from './utils/index.js';

export type SampleContinuousOptions<P extends string> =
  | SampleBaseOptions
  | SamplePointOptions
  | SampleFeatureOptions<GJ.PointObject>
  | SampleFeatureOptions<GJ.LineObject>
  | SampleFeatureOptions<GJ.AreaObject>
  | SampleRelascopePointsOptions<P>
  | SampleSystematicLineOnAreaOptions
  | SampleBeltOnAreaOptions;

export interface SampleStratifiedOptions<
  O extends SampleFiniteOptions | SampleContinuousOptions<P>,
  P extends string,
> {
  stratify: P;
  options: O | O[];
}

/**
 * @returns `null` if check passes, {@link SamplingError} otherwise.
 */
export function sampleStratifiedOptionsCheck<P extends string>(
  {stratify, options}: SampleStratifiedOptions<SampleFiniteOptions | SampleContinuousOptions<P>, P>,
  propertyRecord: PropertyRecord<P>,
): ErrorType<typeof SamplingError> {
  const property = propertyRecord.getId(stratify);
  if (property === null) {
    // stratify must exist on propertyRecord
    return SamplingError.STRATIFY_MISSING;
  }

  if (!PropertyRecord.isCategorical(property)) {
    // stratify prop must be categorical -- no stratification on numerical
    return SamplingError.STRATIFY_NOT_CATEGORICAL;
  }

  if (property.values.length === 0) {
    // stratify prop must have values
    return SamplingError.STRATIFY_NO_VALUES;
  }

  if (Array.isArray(options) && options.length !== property.values.length) {
    // if options is an array, the length must match the number of prop values
    return SamplingError.STRATIFY_OPTIONS_LENGTH_MISMATCH;
  }

  return null;
}

export function sampleStratified<
  IN extends PureObject,
  OUT extends PureObject,
  OPTS extends SampleFiniteOptions | SampleContinuousOptions<P>,
  P extends string,
>(
  sampleFn: (arg0: FeatureCollection<IN, P>, arg1: OPTS) => FeatureCollection<OUT, P>,
  collection: FeatureCollection<IN, P>,
  {stratify, options}: SampleStratifiedOptions<OPTS, P>,
): FeatureCollection<OUT, P> {
  const optionsError = sampleStratifiedOptionsCheck(
    {
      stratify,
      options,
    },
    collection.propertyRecord,
  );
  if (optionsError !== null) {
    throw new RangeError(`sampleStratified error: ${optionsError}`);
  }

  // Already checked that it exists
  const property = collection.propertyRecord.getId(stratify) as CategoricalProperty<P>;
  const optionsArray = Array.isArray(options)
    ? options
    : Array.from<OPTS>({
        length: property.values.length,
      }).fill(options);

  const stratumSampleLayers: FeatureCollection<OUT, P>[] = property.values.map((_, i) => {
    const c = collection.copyEmpty(true);
    collection.features.filter((f) => f.properties[stratify] === i).forEach((f) => c.addFeature(f));
    return sampleFn(c, optionsArray[i]);
  });

  return stratumSampleLayers.reduce((prev, curr) => {
    // TS can't work out if all layers are of same type, which should be
    // guaranteed by all layers being generated by the same function.
    /* eslint-disable-next-line @typescript-eslint/no-unsafe-argument */
    prev.appendFeatureCollection(curr as any);
    return prev;
  });
}
