import {
  AreaObject,
  type CategoricalProperty,
  FeatureCollection,
  type GeoJSON as GJ,
  LineObject,
  PointObject,
  PropertyRecord,
} from '@envisim/geojson-utils';

import {
  SampleBaseOptions,
  SampleBeltOnAreaOptions,
  SampleFeatureOptions,
  SamplePointOptions,
  SampleSystematicLineOnAreaOptions,
} from './sample-continuous/index.js';
import {SampleFiniteOptions} from './sample-finite/index.js';

type SampleContinuousOptions =
  | SampleBaseOptions
  | SamplePointOptions
  | SampleFeatureOptions<GJ.PointFeature>
  | SampleFeatureOptions<GJ.LineFeature>
  | SampleFeatureOptions<GJ.AreaFeature>
  | SampleSystematicLineOnAreaOptions
  | SampleBeltOnAreaOptions;

interface SampleStratifiedOptions<O extends SampleFiniteOptions | SampleContinuousOptions> {
  stratify: string;
  options: O | O[];
}

/**
 * Returns the following errors
 * - 110: stratify does not exist on propertyRecord
 * - 120: stratify property is not categorical
 * - 130: stratify property has no values
 * - 140: options is an array, but its length does not match the length of
 *        stratify property values
 *
 * @returns `0` if check passes
 */
export function sampleStratifiedOptionsCheck(
  fc:
    | FeatureCollection<AreaObject>
    | FeatureCollection<LineObject>
    | FeatureCollection<PointObject>,
  {stratify, options}: SampleStratifiedOptions<SampleFiniteOptions | SampleContinuousOptions>,
): number {
  const property = fc.propertyRecord.getId(stratify);
  if (property === null) {
    // stratify must exist on propertyRecord
    return 110;
  }

  if (!PropertyRecord.propertyIsCategorical(property)) {
    // stratify prop must be categorical -- no stratification on numerical
    return 120;
  }

  if (property.values.length === 0) {
    // stratify prop must have values
    return 130;
  }

  if (Array.isArray(options) && options.length !== property.values.length) {
    // if options is an array, the length must match the number of prop values
    return 140;
  }

  return 0;
}

export function sampleStratified<
  IN extends
    | FeatureCollection<AreaObject>
    | FeatureCollection<LineObject>
    | FeatureCollection<PointObject>,
  OUT extends
    | FeatureCollection<AreaObject>
    | FeatureCollection<LineObject>
    | FeatureCollection<PointObject>,
  OPTS extends SampleFiniteOptions | SampleContinuousOptions,
>(
  sampleFn: (arg0: IN, arg1: OPTS) => OUT,
  fc: IN,
  {stratify, options}: SampleStratifiedOptions<OPTS>,
): OUT {
  const optionsError = sampleStratifiedOptionsCheck(fc, {
    stratify,
    options,
  });
  if (optionsError !== 0) {
    throw new RangeError(`sampleStratified error: ${optionsError}`);
  }

  // Already checked that it exists
  const property = fc.propertyRecord.getId(stratify) as CategoricalProperty;
  const optionsArray = Array.isArray(options)
    ? options
    : Array.from<OPTS>({
        length: property.values.length,
      }).fill(options);

  let stratumSampleLayers: OUT[];

  if (FeatureCollection.isArea(fc)) {
    stratumSampleLayers = property.values.map((_, i) => {
      const features = fc.features.filter((f) => f.properties[stratify] === i);

      return sampleFn(
        FeatureCollection.newArea(features, fc.propertyRecord, true) as IN,
        optionsArray[i],
      );
    });
  } else if (FeatureCollection.isLine(fc)) {
    stratumSampleLayers = property.values.map((_, i) => {
      const features = fc.features.filter((f) => f.properties[stratify] === i);

      return sampleFn(
        FeatureCollection.newLine(features, fc.propertyRecord, true) as IN,
        optionsArray[i],
      );
    });
  } else if (FeatureCollection.isPoint(fc)) {
    stratumSampleLayers = property.values.map((_, i) => {
      const features = fc.features.filter((f) => f.properties[stratify] === i);

      return sampleFn(
        FeatureCollection.newPoint(features, fc.propertyRecord, true) as IN,
        optionsArray[i],
      );
    });
  } else {
    throw Error('Incorrect input Layer');
  }

  const newCollection = stratumSampleLayers.reduce((prev, curr) => {
    // TS can't work out if all layers are of same type, which should be
    // guaranteed by all layers being generated by the same function.
    /* eslint-disable-next-line @typescript-eslint/no-unsafe-argument */
    prev.appendFeatureCollection(curr as any);
    return prev;
  }) as OUT;

  // Add _designWeight to propertyRecord if it does not exist
  newCollection.propertyRecord.addDesignWeight();

  return newCollection;
}
