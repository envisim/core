import {
  AreaObject,
  type CategoricalProperty,
  FeatureCollection,
  type GeoJSON as GJ,
  LineObject,
  PointObject,
  PropertyRecord,
} from '@envisim/geojson-utils';

import {
  SampleBaseOptions,
  SampleBeltOnAreaOptions,
  SampleFeatureOptions,
  SamplePointOptions,
  SampleRelascopePointsOptions,
  SampleSystematicLineOnAreaOptions,
} from './sample-continuous/index.js';
import {SampleFiniteOptions} from './sample-finite/index.js';
import {SamplingError} from './sampling-error.js';
import {type ErrorType} from './utils/index.js';

export type SampleContinuousOptions =
  | SampleBaseOptions
  | SamplePointOptions
  | SampleFeatureOptions<GJ.PointFeature>
  | SampleFeatureOptions<GJ.LineFeature>
  | SampleFeatureOptions<GJ.AreaFeature>
  | SampleBeltOnAreaOptions
  | SampleRelascopePointsOptions
  | SampleSystematicLineOnAreaOptions;

export interface SampleStratifiedOptions<O extends SampleFiniteOptions | SampleContinuousOptions> {
  stratify: string;
  options: O | O[];
}

/**
 * Returns the following errors
 * - {@link SamplingError.STRATIFY_DO_NOT_EXIST}
 * - {@link SamplingError.STRATIFY_NOT_CATEGORICAL}
 * - {@link SamplingError.STRATIFY_NO_VALUES}
 * - {@link SamplingError.STRATIFY_OPTIONS_LENGTH_MISMATCH}
 *
 * @returns `null` if check passes
 */
export function sampleStratifiedOptionsCheck(
  {stratify, options}: SampleStratifiedOptions<SampleFiniteOptions | SampleContinuousOptions>,
  propertyRecord: PropertyRecord,
): ErrorType<typeof SamplingError> {
  const property = propertyRecord.getId(stratify);
  if (property === null) {
    // stratify must exist on propertyRecord
    return SamplingError.STRATIFY_DO_NOT_EXIST;
  }

  if (!PropertyRecord.propertyIsCategorical(property)) {
    // stratify prop must be categorical -- no stratification on numerical
    return SamplingError.STRATIFY_NOT_CATEGORICAL;
  }

  if (property.values.length === 0) {
    // stratify prop must have values
    return SamplingError.STRATIFY_NO_VALUES;
  }

  if (Array.isArray(options) && options.length !== property.values.length) {
    // if options is an array, the length must match the number of prop values
    return SamplingError.STRATIFY_OPTIONS_LENGTH_MISMATCH;
  }

  return null;
}

export function sampleStratified<
  IN extends
    | FeatureCollection<AreaObject>
    | FeatureCollection<LineObject>
    | FeatureCollection<PointObject>,
  OUT extends
    | FeatureCollection<AreaObject>
    | FeatureCollection<LineObject>
    | FeatureCollection<PointObject>,
  OPTS extends SampleFiniteOptions | SampleContinuousOptions,
>(
  sampleFn: (arg0: IN, arg1: OPTS) => OUT,
  collection: IN,
  {stratify, options}: SampleStratifiedOptions<OPTS>,
): OUT {
  const optionsError = sampleStratifiedOptionsCheck(
    {
      stratify,
      options,
    },
    collection.propertyRecord,
  );
  if (optionsError !== null) {
    throw new RangeError(`sampleStratified error: ${optionsError}`);
  }

  // Already checked that it exists
  const property = collection.propertyRecord.getId(stratify) as CategoricalProperty;
  const optionsArray = Array.isArray(options)
    ? options
    : Array.from<OPTS>({
        length: property.values.length,
      }).fill(options);

  let stratumSampleLayers: OUT[];

  if (FeatureCollection.isArea(collection)) {
    stratumSampleLayers = property.values.map((_, i) => {
      const features = collection.features.filter((f) => f.properties[stratify] === i);

      return sampleFn(
        FeatureCollection.newArea(features, collection.propertyRecord, true) as IN,
        optionsArray[i],
      );
    });
  } else if (FeatureCollection.isLine(collection)) {
    stratumSampleLayers = property.values.map((_, i) => {
      const features = collection.features.filter((f) => f.properties[stratify] === i);

      return sampleFn(
        FeatureCollection.newLine(features, collection.propertyRecord, true) as IN,
        optionsArray[i],
      );
    });
  } else if (FeatureCollection.isPoint(collection)) {
    stratumSampleLayers = property.values.map((_, i) => {
      const features = collection.features.filter((f) => f.properties[stratify] === i);

      return sampleFn(
        FeatureCollection.newPoint(features, collection.propertyRecord, true) as IN,
        optionsArray[i],
      );
    });
  } else {
    throw Error('Incorrect input Layer');
  }

  const newCollection = stratumSampleLayers.reduce((prev, curr) => {
    // TS can't work out if all layers are of same type, which should be
    // guaranteed by all layers being generated by the same function.
    /* eslint-disable-next-line @typescript-eslint/no-unsafe-argument */
    prev.appendFeatureCollection(curr as any);
    return prev;
  }) as OUT;

  // Add _designWeight to propertyRecord if it does not exist
  newCollection.propertyRecord.addDesignWeight();

  return newCollection;
}
