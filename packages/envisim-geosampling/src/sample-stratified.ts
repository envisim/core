import {
  AreaCollection,
  type CategoricalProperty,
  type GeoJSON as GJ,
  GeometricPrimitive,
  Layer,
  LineCollection,
  PointCollection,
  type PropertyRecord,
  createDesignWeightProperty,
} from '@envisim/geojson-utils';

import {SamplingError} from './SamplingError.js';
import {
  SampleBaseOptions,
  SampleBeltOnAreaOptions,
  SampleFeatureOptions,
  SamplePointOptions,
  SampleRelascopePointsOptions,
  SampleSystematicLineOnAreaOptions,
} from './sample-continuous/index.js';
import {SampleFiniteOptions} from './sample-finite/index.js';
import {type ErrorType} from './utils/ErrorType.js';

export type SampleContinuousOptions =
  | SampleBaseOptions
  | SamplePointOptions
  | SampleFeatureOptions<GJ.PointFeature>
  | SampleFeatureOptions<GJ.LineFeature>
  | SampleFeatureOptions<GJ.AreaFeature>
  | SampleBeltOnAreaOptions
  | SampleRelascopePointsOptions
  | SampleSystematicLineOnAreaOptions;

export interface SampleStratifiedOptions<
  O extends SampleFiniteOptions | SampleContinuousOptions,
> {
  stratify: string;
  options: O | O[];
}

/**
 * Returns the following errors
 * - {@link SamplingError.STRATIFY_DONT_EXIST}
 * - {@link SamplingError.STRATIFY_NOT_CATEGORICAL}
 * - {@link SamplingError.STRATIFY_NO_VALUES}
 * - {@link SamplingError.STRATIFY_OPTIONS_LENGTH_MISMATCH}
 *
 * @returns `null` if check passes
 */
export function sampleStratifiedOptionsCheck(
  {
    stratify,
    options,
  }: SampleStratifiedOptions<SampleFiniteOptions | SampleContinuousOptions>,
  propertyRecord: PropertyRecord,
): ErrorType<typeof SamplingError> {
  if (!Object.hasOwn(propertyRecord, stratify)) {
    // stratify must exist on propertyRecord
    return SamplingError.STRATIFY_DONT_EXIST;
  }

  const property = propertyRecord[stratify];

  if (property.type !== 'categorical') {
    // stratify prop must be categorical -- no stratification on numerical
    return SamplingError.STRATIFY_NOT_CATEGORICAL;
  }

  if (property.values.length === 0) {
    // stratify prop must have values
    return SamplingError.STRATIFY_NO_VALUES;
  }

  if (Array.isArray(options) && options.length !== property.values.length) {
    // if options is an array, the length must match the number of prop values
    return SamplingError.STRATIFY_OPTIONS_LENGTH_MISMATCH;
  }

  return null;
}

export function sampleStratified<
  IN extends
    | Layer<PointCollection>
    | Layer<LineCollection>
    | Layer<AreaCollection>,
  OUT extends
    | Layer<PointCollection>
    | Layer<LineCollection>
    | Layer<AreaCollection>,
  OPTS extends SampleFiniteOptions | SampleContinuousOptions,
>(
  sampleFn: (arg0: IN, arg1: OPTS) => OUT,
  layer: IN,
  {stratify, options}: SampleStratifiedOptions<OPTS>,
): OUT {
  const optionsError = sampleStratifiedOptionsCheck(
    {
      stratify,
      options,
    },
    layer.propertyRecord,
  );
  if (optionsError !== null) {
    throw new RangeError(`sampleStratified error: ${optionsError}`);
  }

  // Already checked that it exists
  const property = layer.propertyRecord[stratify] as CategoricalProperty;
  const optionsArray = Array.isArray(options)
    ? options
    : Array.from<OPTS>({
        length: property.values.length,
      }).fill(options);

  let stratumSampleLayers: OUT[];
  if (Layer.isLayer(layer, GeometricPrimitive.POINT)) {
    stratumSampleLayers = property.values.map((_, i) => {
      const features = layer.collection.features.filter(
        (f) => f.properties[stratify] === i,
      );

      return sampleFn(
        new Layer(
          new PointCollection({features}, true),
          layer.propertyRecord,
        ) as IN,
        optionsArray[i],
      );
    });
  } else if (Layer.isLayer(layer, GeometricPrimitive.LINE)) {
    stratumSampleLayers = property.values.map((_, i) => {
      const features = layer.collection.features.filter(
        (f) => f.properties[stratify] === i,
      );

      return sampleFn(
        new Layer(
          new LineCollection({features}, true),
          layer.propertyRecord,
        ) as IN,
        optionsArray[i],
      );
    });
  } else if (Layer.isLayer(layer, GeometricPrimitive.AREA)) {
    stratumSampleLayers = property.values.map((_, i) => {
      const features = layer.collection.features.filter(
        (f) => f.properties[stratify] === i,
      );

      return sampleFn(
        new Layer(
          new AreaCollection({features}, true),
          layer.propertyRecord,
        ) as IN,
        optionsArray[i],
      );
    });
  } else {
    throw Error('Incorrect input Layer');
  }

  const newLayer = stratumSampleLayers.reduce((prev, curr) => {
    // TS can't work out if all layers are of same type, which should be
    // guaranteed by all layers being generated by the same function.
    /* eslint-disable-next-line @typescript-eslint/no-unsafe-argument */
    prev.appendFromLayer(curr as any);
    return prev;
  }) as OUT;

  // Add _designWeight to propertyRecord if it does not exist
  if (!Object.hasOwn(newLayer.propertyRecord, '_designWeight')) {
    newLayer.propertyRecord['_designWeight'] = createDesignWeightProperty();
  }

  return newLayer;
}
